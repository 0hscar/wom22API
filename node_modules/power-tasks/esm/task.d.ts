/// <reference types="node" resolution-mode="require"/>
import { AsyncEventEmitter } from 'strict-typed-events';
import './types.js';
export declare type TaskFunction<T = any> = (args: TaskFunctionArgs) => T | Promise<T>;
export declare type TaskLike<T = any> = Task<T> | TaskFunction;
export declare type TaskStatus = 'idle' | 'waiting' | 'running' | 'fulfilled' | 'failed' | 'aborting' | 'aborted';
export interface TaskFunctionArgs {
    task: Task;
    signal: AbortSignal;
}
export interface TaskOptions {
    id?: any;
    name?: string;
    args?: any[];
    children?: TaskLike[] | (() => TaskLike[] | Promise<TaskLike[]>);
    dependencies?: (Task | string)[];
    concurrency?: number;
    bail?: boolean;
    serial?: boolean;
    exclusive?: boolean;
    abortTimeout?: number;
    onStart?: (task: Task) => void;
    onFinish?: (task: Task) => void;
    onRun?: (task: Task) => void;
    onStatusChange?: (task: Task) => void;
    onUpdate?: (task: Task, properties: string[]) => void;
    onUpdateRecursive?: (task: Task, properties: string[]) => void;
}
export interface TaskUpdateValues {
    status?: TaskStatus;
    message?: string;
    error?: any;
    result?: any;
    waitingFor?: boolean;
}
declare class TaskContext {
    executingTasks: Set<Task<any>>;
    queue: Set<Task<any>>;
    concurrency: number;
    triggerPulse: () => void;
}
declare const taskContextKey: unique symbol;
export declare class Task<T = any> extends AsyncEventEmitter {
    protected [taskContextKey]?: TaskContext;
    protected _id: string;
    protected _options: TaskOptions;
    protected _executeFn?: TaskFunction;
    protected _children?: Task[];
    protected _dependencies?: Task[];
    protected _status: TaskStatus;
    protected _message?: string;
    protected _executeDuration?: number;
    protected _error?: any;
    protected _result?: T;
    protected _isManaged?: boolean;
    protected _abortController: AbortController;
    protected _abortTimer?: NodeJS.Timer;
    protected _waitingFor?: Set<Task>;
    protected _failedTasks?: Task[];
    protected _abortedTasks?: Task[];
    protected _childrenLeft?: Set<Task>;
    constructor(children: TaskLike[], options?: Omit<TaskOptions, 'children'>);
    constructor(execute: TaskFunction, options?: TaskOptions);
    get id(): string;
    get name(): string | undefined;
    get children(): Task[] | undefined;
    get options(): TaskOptions;
    get message(): string;
    get status(): TaskStatus;
    get isStarted(): boolean;
    get isFinished(): boolean;
    get isFailed(): boolean;
    get executeDuration(): number | undefined;
    get result(): any;
    get error(): any;
    get dependencies(): Task[] | undefined;
    get needWaiting(): boolean;
    getWaitingTasks(): Task[] | undefined;
    abort(): this;
    start(): this;
    toPromise(): Promise<T>;
    protected _determineChildrenTree(callback: (err?: any) => void): void;
    protected _determineChildrenDependencies(scope: Task[]): void;
    protected _captureDependencies(): void;
    protected _start(): void;
    protected _startChildren(): void;
    protected _pulse(): void;
    protected _update(prop: TaskUpdateValues): void;
    protected _abortChildren(): Promise<void>;
}
export {};
